---
title: 'Callback Configuration'
description: 'Configure webhooks for real-time event notifications and system integration'
---

# Callback Configuration API

The Callbacks API manages webhook subscriptions for real-time event notifications from MasonHub. Register callback URLs to receive immediate notifications when events occur in the system, enabling responsive integrations and real-time data synchronization.

<Note>
All callback URLs must use HTTPS for security. Configure verification tokens for enhanced authentication.
</Note>

## Core Operations

### Get Callback URLs

<api-endpoint method="GET" url="/callbacks" />

Retrieve configured webhook subscriptions and their status information.

<ParamField query="message_type" type="string" default="all">
  Filter by message type or "all" for all types
</ParamField>

<RequestExample>
```bash cURL
curl -X GET "https://app.masonhub.co/{account}/api/v1/callbacks?message_type=skuInventoryChange" \
  -H "Authorization: Bearer your_jwt_token"
```

```python Python
import requests

url = "https://app.masonhub.co/{account}/api/v1/callbacks"
headers = {
    "Authorization": "Bearer your_jwt_token"
}
params = {
    "message_type": "skuInventoryChange"
}

response = requests.get(url, headers=headers, params=params)
data = response.json()
```

```javascript JavaScript
const params = new URLSearchParams({
  message_type: 'skuInventoryChange'
});

const response = await fetch(`https://app.masonhub.co/{account}/api/v1/callbacks?${params}`, {
  method: 'GET',
  headers: {
    'Authorization': 'Bearer your_jwt_token'
  }
});

const data = await response.json();
```
</RequestExample>

<ResponseExample>
```json 200 Success
[
  {
    "id": "callback-uuid-123",
    "url": "https://api.clienturl.com/api/inventory_event",
    "message_type": "skuInventoryChange",
    "api_version": "1.0",
    "token": "encrypted_verification_token",
    "status": "active",
    "created_at": "2018-08-01T10:00:00Z",
    "last_success": "2018-08-06T15:30:00Z",
    "failure_count": 0
  }
]
```

```json 404 Not Found
{
  "error": {
    "code": "NO_CALLBACKS_FOUND",
    "message": "No callback URLs found for specified message type"
  }
}
```
</ResponseExample>

#### Query Parameters

| Parameter | Type | Description | Default |
|-----------|------|-------------|---------|
| `message_type` | string | Filter by message type or "all" | "all" |

### Create Callback URLs

<api-endpoint method="POST" url="/callbacks" />

Register webhook endpoints for real-time event notifications.

<ParamField body="url" type="string" required>
  HTTPS webhook endpoint URL
</ParamField>

<ParamField body="message_type" type="string" required>
  Event type to subscribe to (e.g., "skuInventoryChange", "orderEvent")
</ParamField>

<ParamField body="api_version" type="string" required>
  API version for callbacks (currently "1.0")
</ParamField>

<ParamField body="token" type="string">
  Optional verification token for enhanced security
</ParamField>

<RequestExample>
```bash cURL
curl -X POST "https://app.masonhub.co/{account}/api/v1/callbacks" \
  -H "Authorization: Bearer your_jwt_token" \
  -H "Content-Type: application/json" \
  -d '[
    {
      "url": "https://api.clienturl.com/api/skuInventoryChange",
      "message_type": "skuInventoryChange",
      "api_version": "1.0",
      "token": "your_secure_verification_token"
    },
    {
      "url": "https://api.clienturl.com/api/orderEvent",
      "message_type": "orderEvent",
      "api_version": "1.0"
    }
  ]'
```

```python Python
import requests
import json

url = "https://app.masonhub.co/{account}/api/v1/callbacks"
headers = {
    "Authorization": "Bearer your_jwt_token",
    "Content-Type": "application/json"
}

data = [
    {
        "url": "https://api.clienturl.com/api/skuInventoryChange",
        "message_type": "skuInventoryChange",
        "api_version": "1.0",
        "token": "your_secure_verification_token"
    },
    {
        "url": "https://api.clienturl.com/api/orderEvent",
        "message_type": "orderEvent",
        "api_version": "1.0"
    }
]

response = requests.post(url, headers=headers, data=json.dumps(data))
result = response.json()
```

```javascript JavaScript
const response = await fetch('https://app.masonhub.co/{account}/api/v1/callbacks', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer your_jwt_token',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify([
    {
      url: "https://api.clienturl.com/api/skuInventoryChange",
      message_type: "skuInventoryChange",
      api_version: "1.0",
      token: "your_secure_verification_token"
    },
    {
      url: "https://api.clienturl.com/api/orderEvent",
      message_type: "orderEvent",
      api_version: "1.0"
    }
  ])
});

const data = await response.json();
```
</RequestExample>

<ResponseExample>
```json 200 Success
{
  "records_submitted": 2,
  "records_processed": 2,
  "records_failed": 0,
  "records_succeeded": 2,
  "results": [
    {
      "id": "callback-uuid-123",
      "url": "https://api.clienturl.com/api/skuInventoryChange",
      "message_type": "skuInventoryChange",
      "status": "active"
    },
    {
      "id": "callback-uuid-456",
      "url": "https://api.clienturl.com/api/orderEvent",
      "message_type": "orderEvent",
      "status": "active"
    }
  ]
}
```

```json 400 Validation Error
{
  "error": {
    "code": "INVALID_URL",
    "message": "Callback URL must use HTTPS protocol"
  }
}
```
</ResponseExample>
      "message_type": "orderEvent",
      "status": "active"
    }
  ]
}
```
</CodeGroup>

### Delete Callback URLs

```http
DELETE /callbacks
Authorization: Bearer your_jwt_token
Content-Type: application/json

[
  "callback-uuid-123",
  "callback-uuid-456"
]
```

## Available Event Types

<CardGroup cols={2}>
  <Card
    title="Inventory Events"
    icon="warehouse"
    color="#10b981"
  >
    **skuInventoryChange**: Real-time inventory level updates
    
    **snapshotReady**: Bulk inventory snapshot completion
  </Card>
  <Card
    title="Order Events"
    icon="shopping-cart"
    color="#3b82f6"
  >
    **orderEvent**: Order status changes and fulfillment
    
    **orderUpdateResolution**: Update request results
    
    **orderCancelResolution**: Cancel request results
  </Card>
  <Card
    title="Fulfillment Events"
    icon="truck"
    color="#f59e0b"
  >
    **inboundShipmentEvent**: Receiving status updates
    
    **shipmentEvent**: Outbound shipping notifications
  </Card>
  <Card
    title="Returns & Quality"
    icon="undo"
    color="#ef4444"
  >
    **rmaEvent**: Return merchandise authorization updates
    
    **qualityEvent**: Quality control status changes
  </Card>
</CardGroup>

## Security & Authentication

### HTTPS Requirement

<Warning>
All callback URLs must use HTTPS. HTTP URLs will be rejected for security reasons.
</Warning>

### Verification Tokens

Enhance security with verification tokens:

<Tabs>
  <Tab title="Token Configuration">
    ```json
    {
      "url": "https://api.clienturl.com/webhook",
      "message_type": "orderEvent",
      "token": "your_encrypted_verification_token"
    }
    ```
    
    Tokens are included in callback payloads for verification.
  </Tab>
  <Tab title="Token Verification">
    ```javascript
    // Verify incoming webhook
    function verifyWebhook(payload, expectedToken) {
      if (!expectedToken) return true; // No token configured
      
      return payload.token === expectedToken;
    }
    
    // Example usage
    if (!verifyWebhook(webhookPayload, process.env.MASONHUB_TOKEN)) {
      return res.status(401).send('Unauthorized');
    }
    ```
  </Tab>
</Tabs>

### Request Headers

MasonHub callback requests include identifying headers:

```http
POST /your-webhook-endpoint
User-Agent: MasonHub-Webhook/1.0
Content-Type: application/json
X-MasonHub-Event: orderEvent
X-MasonHub-Delivery: uuid-delivery-id
```

## Callback Payload Format

All callbacks use a consistent structure:

<CodeGroup>
```json Standard Format
{
  "callback_url": "https://client.com/api/webhook",
  "message_type": "orderEvent",
  "message_id": "unique-event-id",
  "api_version": "1.0",
  "timestamp": "2018-08-06T15:11:19Z",
  "token": "verification_token",
  "data": [
    {
      // Event-specific data
    }
  ]
}
```

```json Inventory Change Example
{
  "callback_url": "https://client.com/api/inventory_event",
  "message_type": "skuInventoryChange",
  "message_id": "e58769ec-c4cf-47f9-b80a-378a9b85aeae",
  "api_version": "1.0",
  "timestamp": "2018-11-18T00:43:23Z",
  "data": [
    {
      "sku_id": "e5d00ff6-b34a-496e-9559-eb90e99463af",
      "customer_identifier": "10000",
      "total_units": 200,
      "total_available_to_sell": 150,
      "change_reason": "order_allocation",
      "as_of": "2018-11-18T00:43:23.095637Z"
    }
  ]
}
```
</CodeGroup>

## Delivery Guarantees

### Reliability Features

<Steps>
  <Step title="At-least-once Delivery">
    Events may be delivered multiple times - design idempotent handlers
  </Step>
  <Step title="Retry Logic">
    Failed deliveries are retried with exponential backoff
  </Step>
  <Step title="Timeout Handling">
    Requests timeout after 30 seconds
  </Step>
  <Step title="Error Logging">
    Delivery failures are logged for troubleshooting
  </Step>
</Steps>

### Response Requirements

Your webhook endpoints must:

<CardGroup cols={2}>
  <Card
    title="HTTP 200 Response"
    icon="check-circle"
  >
    Return HTTP 200 status for successful processing
  </Card>
  <Card
    title="Quick Response"
    icon="clock"
  >
    Respond within 30 seconds to avoid timeouts
  </Card>
  <Card
    title="Idempotent Processing"
    icon="sync"
  >
    Handle duplicate events gracefully using message_id
  </Card>
  <Card
    title="Error Handling"
    icon="exclamation-triangle"
  >
    Return appropriate HTTP status codes for different scenarios
  </Card>
</CardGroup>

## Callback Management

### Callback Holds

Temporarily suspend callback delivery when needed:

<Tabs>
  <Tab title="Get Holds">
    ```http
    GET /callback_holds
    Authorization: Bearer your_jwt_token
    ```
    
    List current callback holds by message type.
  </Tab>
  <Tab title="Create Holds">
    ```json
    POST /callback_holds
    
    [
      "skuInventoryChange",
      "orderEvent"
    ]
    ```
    
    Suspend delivery for specific event types.
  </Tab>
  <Tab title="Remove Holds">
    ```json
    DELETE /callback_holds
    
    [
      "skuInventoryChange",
      "orderEvent"
    ]
    ```
    
    Resume delivery for specified event types.
  </Tab>
</Tabs>

### Use Cases for Holds

<Accordion title="Maintenance Windows">
  Suspend callbacks during system maintenance to prevent processing errors and ensure clean resumption.
</Accordion>

<Accordion title="System Overload">
  Temporarily halt callbacks during high-traffic periods to allow systems to catch up.
</Accordion>

<Accordion title="Testing Deployment">
  Pause production callbacks during deployment to prevent test data contamination.
</Accordion>

## Implementation Examples

### Python Flask Webhook

<CodeGroup>
```python Basic Handler
from flask import Flask, request, jsonify
import logging

app = Flask(__name__)

@app.route('/webhook/masonhub', methods=['POST'])
def handle_masonhub_webhook():
    try:
        payload = request.get_json()
        
        # Extract key information
        message_type = payload['message_type']
        message_id = payload['message_id']
        data = payload['data']
        
        # Process based on message type
        if message_type == 'skuInventoryChange':
            handle_inventory_change(data)
        elif message_type == 'orderEvent':
            handle_order_event(data)
        elif message_type == 'inboundShipmentEvent':
            handle_inbound_event(data)
        else:
            logging.warning(f"Unknown message type: {message_type}")
            
        return 'OK', 200
        
    except Exception as e:
        logging.error(f"Webhook error: {e}")
        return 'Error', 500

def handle_inventory_change(data):
    for item in data:
        sku = item['customer_identifier']
        available = item['total_available_to_sell']
        
        # Update local inventory cache
        update_inventory_cache(sku, available)
        
        # Trigger out-of-stock notifications if needed
        if available == 0:
            notify_out_of_stock(sku)

def handle_order_event(data):
    for order in data:
        order_id = order['customer_identifier']
        status = order['status']
        
        # Update order status in local system
        update_order_status(order_id, status)
        
        # Send customer notifications
        if status == 'fulfilled':
            send_shipping_notification(order)
```

```python Enhanced Security
from flask import Flask, request, jsonify
import hashlib
import hmac
import os

app = Flask(__name__)

def verify_webhook_signature(payload, signature, secret):
    """Verify webhook signature for enhanced security"""
    expected_signature = hmac.new(
        secret.encode('utf-8'),
        payload,
        hashlib.sha256
    ).hexdigest()
    
    return hmac.compare_digest(signature, expected_signature)

@app.route('/webhook/masonhub', methods=['POST'])
def handle_masonhub_webhook():
    try:
        # Get raw payload for signature verification
        raw_payload = request.get_data()
        signature = request.headers.get('X-MasonHub-Signature')
        
        # Verify signature if configured
        webhook_secret = os.getenv('MASONHUB_WEBHOOK_SECRET')
        if webhook_secret and signature:
            if not verify_webhook_signature(raw_payload, signature, webhook_secret):
                return 'Unauthorized', 401
        
        payload = request.get_json()
        
        # Verify token if configured
        expected_token = os.getenv('MASONHUB_VERIFICATION_TOKEN')
        if expected_token and payload.get('token') != expected_token:
            return 'Unauthorized', 401
            
        # Check for duplicate processing
        message_id = payload['message_id']
        if is_duplicate_message(message_id):
            return 'Already processed', 200
            
        # Mark message as processed
        mark_message_processed(message_id)
        
        # Process the webhook
        process_webhook(payload)
        
        return 'OK', 200
        
    except Exception as e:
        logging.error(f"Webhook error: {e}")
        return 'Error', 500
```
</CodeGroup>

### Node.js Express Webhook

```javascript
const express = require('express');
const crypto = require('crypto');

const app = express();
app.use(express.json());

// Middleware for webhook verification
function verifyWebhook(req, res, next) {
  const token = req.body.token;
  const expectedToken = process.env.MASONHUB_TOKEN;
  
  if (expectedToken && token !== expectedToken) {
    return res.status(401).send('Unauthorized');
  }
  
  next();
}

// Idempotency tracking
const processedMessages = new Set();

app.post('/webhook/masonhub', verifyWebhook, async (req, res) => {
  try {
    const { message_type, message_id, data } = req.body;
    
    // Check for duplicate
    if (processedMessages.has(message_id)) {
      return res.status(200).send('Already processed');
    }
    
    // Mark as processed
    processedMessages.add(message_id);
    
    // Process based on message type
    switch (message_type) {
      case 'skuInventoryChange':
        await handleInventoryChange(data);
        break;
      case 'orderEvent':
        await handleOrderEvent(data);
        break;
      default:
        console.warn(`Unknown message type: ${message_type}`);
    }
    
    res.status(200).send('OK');
    
  } catch (error) {
    console.error('Webhook error:', error);
    res.status(500).send('Error');
  }
});
```

## Testing & Development

### Sandbox Environment

Test callbacks in the sandbox environment:

<CardGroup cols={2}>
  <Card
    title="Sandbox Base URL"
    icon="flask"
  >
    `https://sandbox.masonhub.co/{account}/api/v1/callbacks`
    
    All callback types available for testing
  </Card>
  <Card
    title="Test Event Generation"
    icon="play"
  >
    Use DataFactory to trigger test events and validate your webhook handlers
  </Card>
</CardGroup>

### Development Tools

<Tabs>
  <Tab title="ngrok for Local Testing">
    ```bash
    # Install ngrok
    npm install -g ngrok
    
    # Expose local server
    ngrok http 3000
    
    # Use the HTTPS URL for callback registration
    # https://abc123.ngrok.io/webhook/masonhub
    ```
  </Tab>
  <Tab title="Webhook Testing Service">
    ```bash
    # Use webhook.site for quick testing
    curl -X POST https://webhook.site/unique-id \
      -H "Content-Type: application/json" \
      -d '{
        "message_type": "orderEvent",
        "message_id": "test-123",
        "data": [{"test": "data"}]
      }'
    ```
  </Tab>
</Tabs>

## Monitoring & Troubleshooting

### Common Issues

<Accordion title="HTTPS Required">
  **Problem**: HTTP URLs rejected
  
  **Solution**: Use only HTTPS URLs for callback endpoints
  
  **Test**: `curl -I https://yoursite.com/webhook`
</Accordion>

<Accordion title="Timeout Issues">
  **Problem**: Callbacks timing out after 30 seconds
  
  **Solution**: Process webhooks asynchronously or return 200 immediately
  
  **Pattern**: Queue events for background processing
</Accordion>

<Accordion title="Duplicate Processing">
  **Problem**: Same event processed multiple times
  
  **Solution**: Implement idempotency using message_id
  
  **Storage**: Track processed message IDs in database or cache
</Accordion>

### Monitoring Best Practices

<CardGroup cols={2}>
  <Card
    title="Response Time Monitoring"
    icon="stopwatch"
  >
    Track webhook response times to ensure sub-30-second processing
  </Card>
  <Card
    title="Error Rate Tracking"
    icon="chart-line"
  >
    Monitor HTTP error rates and implement alerting for failures
  </Card>
  <Card
    title="Queue Depth Monitoring"
    icon="layer-group"
  >
    Track async processing queue depth if using background processing
  </Card>
  <Card
    title="Duplicate Detection"
    icon="copy"
  >
    Monitor duplicate message rates to optimize idempotency handling
  </Card>
</CardGroup>

## Best Practices

### Security

1. **Use HTTPS Only**: Never accept HTTP callback URLs
2. **Verify Tokens**: Implement token verification for all callbacks
3. **Rate Limiting**: Implement rate limiting on webhook endpoints
4. **Input Validation**: Validate all incoming webhook data

### Performance

1. **Quick Response**: Return HTTP 200 within 30 seconds
2. **Async Processing**: Queue heavy processing for background workers
3. **Idempotency**: Handle duplicate events using message_id
4. **Error Handling**: Return appropriate HTTP status codes

### Reliability

1. **Monitoring**: Implement comprehensive webhook monitoring
2. **Alerting**: Set up alerts for webhook failures
3. **Logging**: Log all webhook events for troubleshooting
4. **Testing**: Regularly test webhook endpoints

## Next Steps

After implementing callback configuration, explore:

- [Order Management](/api/orders) for order event handling
- [Inventory Management](/api/inventory) for inventory change events
- [Authentication](/api/authentication) for secure API access
